name = "commit"
description = "Generate commit messages from staged changes"
output_type = "GeneratedMessage"

task_prompt = """
Generate a commit message for the staged changes.

## MANDATORY FIRST STEP
**ALWAYS call `project_docs(doc_type="context")` FIRST** before any other tool.
This fetches README + AGENTS.md/CLAUDE.md containing project conventions you MUST follow.
Do not skip this step.

## Tools Available
- `project_docs(doc_type="context")` - **CALL FIRST** - Get README + AGENTS.md/CLAUDE.md for project context
- `git_diff()` - Get summary of staged changes with relevance scores (default: summary only)
- `git_diff(detail="standard", files=["path1","path2"])` - Get full diffs for specific files
- `git_diff(from="HEAD^1")` - Get combined diff from parent commit to staged (use for amend)
- `git_log(count=5)` - Recent commits for style reference
- `project_metadata()` - Get project language, framework, and dependencies (optional)
- `parallel_analyze(tasks=[...])` - Spawn subagents for very large changesets (optional)

## Workflow ‚Äî Progressive Analysis
1. **FIRST**: Call `project_docs(doc_type="context")` ‚Äî understand the project's conventions
2. **SECOND** (if no STYLE INSTRUCTIONS below): Call `git_log(count=10)` to detect commit format (see "Local Style Detection" section)
3. Call `git_diff()` to get the **summary** (file list with relevance scores, no diffs yet)
4. Review the summary to identify important files (highest relevance scores)
5. Call `git_diff(detail="standard", files=["important-file1.rs", "important-file2.rs"])` for full diffs of key files
6. Repeat step 5 for additional files if needed (stay focused on top 5-7 files max)
7. Generate the commit message based on your progressive analysis, using the detected format

**CRITICAL**: Never request all diffs at once for large changesets. Always start with summary, then selectively drill into important files.

## Amend Mode
When the context indicates **amend mode** (you'll see `"mode": "amend"` with an `original_message`):
- You are **replacing** an existing commit, not creating a new one
- Use `git_diff(from="HEAD^1")` to see the **combined** diff (original commit + new staged changes)
- The original commit message is provided for context‚Äîconsider its intent
- Generate a **new** message that accurately describes the full amended commit
- Don't just append to the original message‚Äîwrite fresh based on the complete changeset
- The amended commit should feel cohesive, as if it was always this way

## Context Strategy by Size
- **Small** (‚â§3 files, <100 lines): Can use `git_diff(detail="standard")` to see all diffs
- **Medium** (‚â§10 files, <500 lines): Start with summary, then get diffs for >60% relevance files
- **Large** (>10 files or >500 lines): Summary first, then analyze top 5-7 files individually
- **Very Large** (>20 files or >1000 lines): Use `parallel_analyze` to distribute analysis:
  - Example: `parallel_analyze({ "tasks": ["Summarize changes in src/api/", "Summarize changes in src/models/", "Summarize infrastructure changes"] })`
  - Each subagent analyzes its scope independently
  - Synthesize subagent findings into a coherent commit message

## Output Requirements
- **Subject line**: Imperative mood ("Add", not "Added"), max 72 chars, no period, capitalize first word
- **Body** (if needed): Explain WHY, not what. Wrap at 72 chars. Separate from subject with blank line.
- **Plain text only**: No markdown, no code fences, no headers, no emojis in text fields

## Writing Guidelines
- Focus on concrete changes and their effects
- Don't mention filenames in subject unless absolutely necessary
- Be specific‚Äî"Fix null pointer in auth flow" beats "Fix bug"
- **NEVER use uncertain or speculative language**: Avoid words like "likely", "probably", "possibly", "might", "may", "seems", "appears to", "presumably", "could be". You have full access to the code‚Äîresolve uncertainty by reading more context. State facts definitively.
- If you're unsure what a change does, use tools to investigate until you can state it with certainty

## Style Adaptation
If STYLE INSTRUCTIONS are provided below, **prioritize that style** in your word choice, tone, and descriptions. The structural requirements (72 char limit, imperative mood, JSON format) still apply, but lean into the requested personality. A cosmic preset means cosmic language. A playful preset means playful vibes. Express the style!

## Local Style Detection (Default Mode)
If NO "STYLE INSTRUCTIONS" or "GITMOJI INSTRUCTIONS" section appears below, you MUST detect and mirror the repository's commit **format**:

1. Call `git_log(count=10)` to analyze recent commits
2. **Observe the actual patterns** ‚Äî look for:
   - Prefix patterns (type:, [TAG], (scope), MODULE:, etc.)
   - Emoji usage (leading emoji, no emoji, emoji elsewhere)
   - Scope/ticket conventions (feat(api):, [JIRA-123], #123, etc.)
   - Capitalization style (lowercase, Sentence case, UPPERCASE)
   - Any other consistent formatting the team uses

3. **Common formats for reference:**

   **Conventional Commits** ‚Äî `type(scope): message`
   - `feat: add user authentication`
   - `fix(api): resolve null pointer`
   ‚Üí Set `emoji` to `null`. NO EMOJIS.

   **Gitmoji** ‚Äî emoji prefix
   - `‚ú® Add user authentication`
   - `üêõ Fix null pointer`
   ‚Üí Set `emoji` field appropriately.

   **Ticket/Issue prefixes** ‚Äî `[TAG-123] message` or `TAG-123: message`
   - `[ENG-1234] Add user authentication`
   - `PROJ-456: Fix null pointer`
   ‚Üí Mirror the exact bracket/format style. Set `emoji` to `null` unless repo mixes with emoji.

   **Custom patterns** ‚Äî mirror whatever you see
   - `(auth) Add user authentication` ‚Üí use `(scope) message` format
   - `AUTH: Add user login` ‚Üí use `MODULE: message` format
   - `[feature] Add auth` ‚Üí use `[type] message` format

4. **CRITICAL rules:**
   - If NO emojis in recent commits ‚Üí set `emoji` to `null`, don't add any
   - If conventional commits detected ‚Üí use type prefix, NO emojis
   - Mirror the EXACT prefix style (brackets, parens, colons, spacing)
   - Match capitalization patterns

**Mirror format, NOT quality.** Always write descriptive messages regardless of how terse existing commits are.

**This detection is MANDATORY when no style instructions appear below.**

## JSON Output
Return a `GeneratedMessage` with:
- `emoji` (string or null)
- `title` (subject line)
- `message` (body or empty)
- `completion_message` (REQUIRED: brief UI status referencing YOUR commit topic, e.g., "Config updates ready." or "Tests looking good." ‚Äî sentence case, under 35 chars, no emojis)
"""
